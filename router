#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, math

#DEBUG = True
DEBUG = False

parser = argparse.ArgumentParser(description='route packets')
parser.add_argument('asn', type=int, help="AS Number")
parser.add_argument('networks', metavar='networks', type=str, nargs='+', help="networks")
args = parser.parse_args()

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# internal route info
CUST = "cust"
PEER = "peer"
PROV = "prov"


class updateMes:
    srcif = None
    src = None
    dst = None
    #typ = "update"
    network = None
    netmask = None
    localpref = None
    selfOrigin = None
    ASPath = None
    origin = None
    packet = None

    def __init__(self, srcif, packet, s, d, netw, netm, lp, so, asp, ori):
        self.srcif = srcif
        self.packet = packet
        self.src = s
        self.dst = d
        self.network = netw
        self.netmask = netm
        self.localpref = lp
        self.selfOrigin = so
        self.ASPath = asp
        self.origin = ori


class tableEntry:
    ntwork = None
    ntmask = None
    peer = None

    def __init__(self, ntw, ntm, p):
        self.ntwork = ntw
        self.ntmask = ntm
        self.peer = p

##########################################################################################

class Router:

    routes = None
    updates = None
    relations = None
    sockets = None
    table = None
    socketReal = None
    asp = None

    def __init__(self, networks, asn):
        self.routes = []
        self.updates = []
        self.relations = {}
        self.sockets = {}
        self.socketsReal = []
        self.table = []
        self.asp = asn
        #print("self asp: " + self.asp)
        for relationship in networks:
            network, relation = relationship.split("-")
            if DEBUG: 
                print("Starting socket for", network, relation)
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            self.socketsReal.append(sock)
            self.sockets[network] = sock#socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            self.sockets[network].setblocking(0)
            self.sockets[network].connect(network)
            self.relations[network] = relation
        return

    def lookup_routes(self, daddr):
        """ Lookup all valid routes for an address """
        # TODO
        outroutes = []
        return outroutes

    def get_shortest_as_path(self, routes):
        """ select the route with the shortest AS Path """
        # TODO
        outroutes = []
        return outroutes
            
    def get_highest_preference(self, routes):
        """ select the route with the shortest AS Path """
        # TODO
        outroutes = []
        return outroutes
         
    def get_self_origin(self, routes):
        """ select self originating routes """
        # TODO
        outroutes = []
        return outroutes

    def get_origin_routes(self, routes):
        """ select origin routes: IGP > EGP > UNK """
        # TODO
        outroutes = []
        return outroutes

    def filter_relationships(self, srcif, routes):
        """ Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
        outroutes = []
        return outroutes

    def get_route(self, srcif, daddr):
        """	Select the best route for a given address	"""
        # TODO
        peer = None
        routes = lookup_routers(daddr)
        # Rules go here
        if routes:
            # 1. Highest Preference
            routes = self.get_highest_preference(routes)
            # 2. Self Origin
            routes = self.get_self_origin(routes)
            # 3. Shortest ASPath
            routes = self.get_shortest_as_path(routes)
            # 4. IGP > EGP > UNK
            routes = self.get_origin_routes(routes)
            # 5. Lowest IP Address
            # TODO
            # Final check: enforce peering relationships
            routes = self.filter_relationships(srcif, routes)
        return self.sockets[peer] if peer else None

    def forward(self, srcif, packet):
        """	Forward a data packet	"""
        # TODO
        m1 = json.dumps(packet)
        #m = json.loads(m1)
        for sock in self.sockets:
            print(sock) 
        socks = self.socketsReal #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        print(len(socks))
        for s in socks:
            #print("scrif: " + srcif + "socket: " + s)
            for sock in self.sockets:
                        if self.sockets[sock] == s:
                            print("srcif: " + srcif + "sock: " + sock)
                            #s.sendall(bytes(m1, 'utf-8'))
                            
                            if sock != srcif:
                                s.sendall(bytes(m1, 'utf-8'))
                            else:
                                print("stopped from being sent" + "srcif: " + srcif + "sock: " + sock)
        #send out the packet which is the message we just recieved
        return True

    def coalesce(self):
        """	coalesce any routes that are right next to each other	"""
        # TODO (this is the most difficult task, save until last)
        return False

    def sendUpdates(self, upMes):
        #have to fix bc packet is actually an isntance of updateMes
        #which is a bunch of fields not json
        #but srcif is within packet which is good atleast
        #I pushed the last sorking version before I started this
        packet = upMes.packet
        srcif = upMes.srcif
        m1 = json.dumps(packet)
        m = json.loads(m1)
        for sock in self.sockets:
            print(sock)
        socks = self.socketsReal #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        print(len(socks))
        editedMes = m
        msg = m[MESG]
        oldASP = msg['ASPath']
        print(type(oldASP))
        #editedMes['src'] = m['dst']

        for s in socks:
            #print("scrif: " + srcif + "socket: " + s)
            for sock in self.sockets:
                        if self.sockets[sock] == s:
                            print("srcif: " + srcif + "sock: " + sock)
                            #s.sendall(bytes(m1, 'utf-8'))

                            if sock != srcif:
                                editedMes['dst'] = sock
                                z = [self.asp]
                                #for x in oldASP:
                                z = oldASP + z
                                msg['ASPath'] = z
                                print("z: ",z)
                                newDST = editedMes['dst']
                                editedMes['src'] = newDST[0:len(newDST) - 1] + "1"
                                editedMes['msg'] = msg
                                eMes = json.dumps(editedMes)
                                print("sending message: " + eMes)
                                s.sendall(bytes(eMes, 'utf-8')) #was m1
                            else:
                                print("stopped from being sent" + "srcif: " + srcif + "sock: " + sock)
        return True

    def update(self, srcif, packet):
        """	handle update packets	"""
        # TODO
        m1 = json.dumps(packet)
        m = json.loads(m1)
        src = m[SRCE]
        dst = m[DEST]
        typ = m[TYPE]

        msg = m[MESG]
        f1 = json.dumps(msg)
        f = json.loads(f1)
        ntwork = f[NTWK]
        ntmask = f[NMSK]
        origin = f[ORIG]
        lp = f[LPRF]
        aspath = f[APTH]
        sOrigin = f[SORG]
        
        upMes = updateMes(srcif, packet, src, dst, ntwork, ntmask, origin, lp, aspath, sOrigin)
        self.updates.append(upMes)
        #saved an instance of the message

        #adding new instance to table
        t = tableEntry(ntwork, ntmask, src)
        self.table.append(t)
        #for x in self.table:
            #print("ntwork: " + x.ntwork + "ntmask: " + x.ntmask + "peer: " + x.peer)
        
        #m2 = json.dumps(packet)
        #m = json.loads(m1)
        """for sock in self.sockets:
            print(sock)
        socks = self.socketsReal #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        print(len(socks))
        editedMes = m
        oldASP = msg['ASPath']
        print(type(oldASP))
        #editedMes['src'] = m['dst']
        
        for s in socks:
            #print("scrif: " + srcif + "socket: " + s)
            for sock in self.sockets:
                        if self.sockets[sock] == s:
                            print("srcif: " + srcif + "sock: " + sock)
                            #s.sendall(bytes(m1, 'utf-8'))

                            if sock != srcif:
                                editedMes['dst'] = sock
                                z = [self.asp]
                                #for x in oldASP:
                                z = z + oldASP
                                msg['ASPath'] = z
                                print("z: ",z)
                                newDST = editedMes['dst']
                                editedMes['src'] = newDST[0:len(newDST) - 1] + "1" 
                                editedMes['msg'] = msg
                                eMes = json.dumps(editedMes)
                                print("sending message: " + eMes)
                                s.sendall(bytes(eMes, 'utf-8')) #was m1
                            else:
                                print("stopped from being sent" + "srcif: " + srcif + "sock: " + sock)
        #send out the packet which is the message we just recieved"""
        return True
    
    def revoke(self, packet):
        """	handle revoke packets	"""
        # TODO
        return True

    def dump(self, srcif, packet):
        """	handles dump table requests	"""
        # TODO
        m1 = json.dumps(packet)
        m = json.loads(m1)
        msg = m[MESG]
        msg = []
        
        msg2 = json.dumps(msg)
        print(len(self.table))
        x = 0
        l = len(msg2)
        msg2 = msg2[: l-1]
        print("msg without }: " + msg2)
        for t in self.table:
            msg.append({"network":t.ntwork, "netmask": t.ntmask, "peer": t.peer})
            print("below appending")
            
            #msg.update(entry)
        #print("msg using update: " + json.dumps(msg))               
        print("message sending: " + msg)
        #msg3 = json.loads(msg2)
        m[MESG] = msg # to add the actual part make it msg2 but then it doesn't work and is werid
        print("got here")
        socks = self.socketsReal 
        for s in socks:
            
            for sock in self.sockets:
                        if self.sockets[sock] == s:
                            print("got here2")
                            if sock == srcif:
                                print("should get here once")
                                mes = json.dumps(m)
                                print("full dump message: " + mes)
                                s.sendall(bytes(mes, 'utf-8'))
        return True

    def handle_packet(self, srcif, packet):
        """	dispatches a packet """
        # TODO
        m1 = json.dumps(packet)
        m = json.loads(m1)
        #m = m.replace("\'", "\"")
        t = m["type"]
        if t == DATA:
            return self.forward(srcif, packet)
        elif t == DUMP:
            return self.dump(srcif, packet)
        elif t == UPDT:
            return self.update(srcif, packet)
        elif t == RVKE:
            return self.revoke(packet)
        else:
            return False

    def send_error(self, conn, msg):
        """ Send a no_route error message """
        # TODO
        return

    def run(self):
        lastUpdate = True
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            #print("len socks: ")
            #print( len(socks))
            for conn in socks:
                try:
                    k = conn.recv(65535)
                except:
                    # either died on a connection reset, or was SIGTERM's by parent
                    return
                if k:
                    for sock in self.sockets:
                        if self.sockets[sock] == conn:
                            srcif = sock
                    msg = json.loads(k)
                    print(msg)
                    m1 = json.dumps(msg)
                    m = json.loads(m1)
                    t = m["type"]
                    if lastUpdate and t != UPDT:
                        #lsat one was update and now its not
                        #so can send all of the update messages now
                        lastUpdate = False
                        print("can send update messages now")
                        for x in self.updates:
                            #what is the srcif I'm sending?
                            self.sendUpdates(x)
                    if not self.handle_packet(srcif, msg):
                        self.send_error(conn, msg)
                else:
                    return
        #now start sending everything
        return



if __name__ == "__main__":
    router = Router(args.networks, args.asn)
    router.run()
