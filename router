#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, math

#DEBUG = True
DEBUG = False

parser = argparse.ArgumentParser(description='route packets')
parser.add_argument('asn', type=int, help="AS Number")
parser.add_argument('networks', metavar='networks', type=str, nargs='+', help="networks")
args = parser.parse_args()

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# internal route info
CUST = "cust"
PEER = "peer"
PROV = "prov"


class updateMes:
    srcif = None
    src = None
    dst = None
    #typ = "update"
    network = None
    netmask = None
    localpref = None
    selfOrigin = None
    ASPath = None
    origin = None
    packet = None

    def __init__(self, srcif, packet, s, d, netw, netm, lp, so, asp, ori):
        self.srcif = srcif
        self.packet = packet
        self.src = s
        self.dst = d
        self.network = netw
        self.netmask = netm
        self.localpref = lp
        self.selfOrigin = so
        self.ASPath = asp
        self.origin = ori

class revokeMes:
    src = None
    dst = None
    networks = None
    netmasks = None

    def __init__(self, src, dst, networks, netmasks):
        self.src = src
        self.dst = dst
        self.networks = networks
        self.netmasks = netmasks

class tableEntry:
    ntwork = None
    ntmask = None
    peer = None
    localpref = None
    selfOrigin = None
    ASPath = None
    origin = None

    def __init__(self, ntw, ntm, p, lp, so, asp, o):
        self.ntwork = ntw
        self.ntmask = ntm
        self.peer = p
        self.localpref = lp
        self.selfOrigin = so
        self.ASPath = asp
        self.origin = o

##########################################################################################

class Router:

    routes = None
    updates = None
    relations = None
    sockets = None
    table = None
    socketReal = None
    asp = None
    netw = None
    revokes = None

    def __init__(self, networks, asn):
        self.routes = []
        self.updates = []
        self.relations = {}
        self.sockets = {}
        self.socketsReal = []
        self.table = []
        self.asp = asn
        self.netw = []
        self.revokes = []
        #print("self asp: " + self.asp)
        for relationship in networks:
            network, relation = relationship.split("-")
            if DEBUG: 
                print("Starting socket for", network, relation)
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            self.socketsReal.append(sock)
            self.sockets[network] = sock#socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
            self.sockets[network].setblocking(0)
            self.sockets[network].connect(network)
            self.relations[network] = relation
            self.netw.append(network)
        return

    def lookup_routes(self, daddr):
        """ Lookup all valid routes for an address """
        # TODO
        outroutes = []
        addrParts = daddr.split(".")
        
        for t in self.table:
            net = t.ntwork
            src = t.peer
            tableParts = net.split(".")
            
            add = True
            x = 0
            
            while x < len(addrParts):
                
                if addrParts[x] == tableParts[x] or tableParts[x] == "0":
                    add = add and True
                else:
                    add = False
                x = x + 1
            
            if add:
                outroutes.append(t)
            	
        
        return outroutes

    def get_shortest_as_path(self, routes):
        """ select the route with the shortest AS Path """
        # TODO
        outroutes = []
        #print("route type", type(routes))
        shortest = routes[0]
        tied = []
        for r in routes:
            path = r.ASPath
            if path < shortest.ASPath:
                highest = r
                tied = []
            elif path == shortest.ASPath and r != shortest:
                tied.append(r)
        outroutes = tied
        outroutes.append(shortest)
        return outroutes
            
    def get_highest_preference(self, routes):
        """ select the route with the highest localpref """
        # TODO
        outroutes = []
        highest = routes[0]
        tied = []
        for r in routes:
            pref = r.localpref
            if pref > highest.localpref:
                highest = r
                tied = []
            elif pref == highest.localpref and r != highest:
                tied.append(r)
        outroutes = tied
        outroutes.append(highest)
        return outroutes
         
    def get_self_origin(self, routes):
        """ select self originating routes """
        # TODO
        outroutes = []
        t = []
        for r in routes:
            if r.selfOrigin:
                t.append(r)
        if len(t) == 0:
            outroutes = routes
        else:
            outroutes = t
        return outroutes

    def get_origin_routes(self, routes):
        """ select origin routes: IGP > EGP > UNK """
        # TODO
        outroutes = []
        igp = []
        egp = []
        unk = []
        for r in routes:
            if r.origin == "IGP":
                igp.append(r)
            elif r.origin == "EGP":
                egp.append(r)
            elif r.origin == "UNK":
                unk.append(r)
        if len(igp) != 0:
            outroutes = igp
        elif len(egp) != 0:
            outroutes = egp
        else:
            outroutes = unk
        return outroutes

    def filter_relationships(self, srcif, routes):
        """ Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
        outroutes = []
        
        socks = self.socketsReal
        #for n in self.netw:
        for s in socks:
            for n in self.netw: #new   
                for sock in self.sockets:
                    if self.sockets[n] == s:
                        if n == srcif:
                            relation1 = self.relations[n]
             
        
        for r in routes:
            
            #for n in self.netw:
                for s in socks:
                    for n in self.netw: #for sock in self.sockets:
                        if self.sockets[n] == s: #used to take sock
                            if n == r.peer:
                                relation2 = self.relations[n]
                                
                                condition1 = relation1 == "peer" and relation2 == "peer"
                                condition2 = relation1 == "peer" and relation2 == "prov"
                                condition3 = relation1 == "prov" and realtion2 == "peer"
                                if (not condition1) and (not condition2) and (not condition3):
                                    outroutes.append(r)
                

        return outroutes

    def get_route(self, srcif, daddr):
        """	Select the best route for a given address	"""
        # TODO
        peer = None
        
        routes = self.lookup_routes(daddr)
        # Rules go here
        if routes:
            #i 1. Highest Preference
            routes = self.get_highest_preference(routes)
            # 2. Self Origin
            routes = self.get_self_origin(routes)
            # 3. Shortest ASPath
            routes = self.get_shortest_as_path(routes)
            # 4. IGP > EGP > UNK
            routes = self.get_origin_routes(routes)
            # 5. Lowest IP Address
            # TODO
            # Final check: enforce peering relationships
            routes = self.filter_relationships(srcif, routes)
            
        if len(routes) > 0:
            peer = routes[0].peer
            
        return peer if peer else None #self.sockets[peer] if peer else None

    def forward(self, srcif, packet):
        """	Forward a data packet	"""
        # TODO
        #think I need to look at the destination of the given data message and see what table entry it matches
        #and then if it matches the table take the source which sent that message from the table and 
        #send the data message to only them?
        m1 = json.dumps(packet)
        m = json.loads(m1)
        
        socks = self.socketsReal
        
        
        net = m['dst']
        
        sendto = self.get_route(srcif, net)

        
        if sendto == None:
             for s in socks:
                 for sock in self.sockets:
                     if self.sockets[sock] == s:        
                         m['msg'] = {}
                         m['type'] = "no route"
                         m['dst'] = m['src']
                         m['src'] = sock[0:len(sock) - 1] + "1"
                         eMes = json.dumps(m)
                         s.sendall(bytes(eMes, 'utf-8'))
        else:                 
            for s in socks:
                for sock in self.sockets:
                    if self.sockets[sock] == s:
                        
                        if sock == sendto: #changes
                            
                            eMes = json.dumps(m)
                            s.sendall(bytes(eMes, 'utf-8'))
                            #return True
        
        return True

    def coalesce(self):
        """	coalesce any routes that are right next to each other	"""
        # TODO (this is the most difficult task, save until last)
        return False

    def sendUpdates(self, upMes):
        #have to fix bc packet is actually an isntance of updateMes
        #which is a bunch of fields not json
        #but srcif is within packet which is good atleast
        #I pushed the last sorking version before I started this
        packet = upMes.packet
        srcif = upMes.srcif
        m1 = json.dumps(packet)
        m = json.loads(m1)
        
        socks = self.socketsReal #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        editedMes = m
        msg = m[MESG]
        oldASP = msg['ASPath']
        
        for s in socks:
            
            for sock in self.sockets:
                        if self.sockets[sock] == s:
                            
                            if sock != srcif:
                                editedMes['dst'] = sock
                                z = [self.asp]
                                
                                z = oldASP + z
                                msg['ASPath'] = z
                                
                                newDST = editedMes['dst']
                                editedMes['src'] = newDST[0:len(newDST) - 1] + "1"
                                editedMes['msg'] = msg
                                eMes = json.dumps(editedMes)
                                print("sending message: " + eMes)
                                s.sendall(bytes(eMes, 'utf-8'))
        return True

    def update(self, srcif, packet):
        """	handle update packets	"""
        # TODO
        m1 = json.dumps(packet)
        m = json.loads(m1)
        src = m[SRCE]
        dst = m[DEST]
        typ = m[TYPE]

        msg = m[MESG]
        f1 = json.dumps(msg)
        f = json.loads(f1)
        ntwork = f[NTWK]
        ntmask = f[NMSK]
        origin = f[ORIG]
        lp = f[LPRF]
        aspath = f[APTH]
        sOrigin = f[SORG]
        
        upMes = updateMes(srcif, packet, src, dst, ntwork, ntmask, origin, lp, aspath, sOrigin)
        self.updates.append(upMes)
        #saved an instance of the message

        #adding new instance to table
        t = tableEntry(ntwork, ntmask, src, lp, sOrigin, aspath, origin)
        self.table.append(t)
        
        return True
    
    def revoke(self, packet):
        """	handle revoke packets	"""
        # TODO
        m1 = json.dumps(packet)
        m = json.loads(m1)
        src = m[SRCE]
        dst = m[DEST]
        typ = m[TYPE]

        msg = m[MESG]
        print("type of message: ", type(msg))
        networks = []
        netmasks = []
        for n in msg:
            n1 = json.dumps(n)
            n2 = json.loads(n1)
            netw = n2["network"]
            netm = n2["netmask"]
            networks.append(netw)
            netmasks.append(netm)        

        revMes = revokeMes(src, dst, networks, netmasks)
        self.revokes.append(revMes)
        toRemove = []
        for t in self.table:
            print("within table")
            x = 0
            while x < len(networks):
                print("table network and mask: " + t.ntwork + " " + t.ntmask)
                print("network and mask from list: " + networks[x] + " " + netmasks[x])
                if t.ntwork == networks[x] and t.ntmask == netmasks[x] and t.peer == src:
                    toRemove.append(t)
                x = x + 1

        for r in toRemove:
            self.table.remove(r)
        
        #sending revoke message to neighbors
        
        srcif = src
        
        socks = self.socketsReal #@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
        editedMes = m
        

        for s in socks:

            for sock in self.sockets:
                        if self.sockets[sock] == s:

                            if sock != srcif:
                                editedMes['dst'] = sock

                                newDST = editedMes['dst']
                                editedMes['src'] = newDST[0:len(newDST) - 1] + "1"
                                
                                eMes = json.dumps(editedMes)
                                print("sending message: " + eMes)
                                s.sendall(bytes(eMes, 'utf-8'))

        return True

    def dump(self, srcif, packet):
        """	handles dump table requests	"""
        # TODO
        m1 = json.dumps(packet)
        m = json.loads(m1)
        msg = m[MESG]
        msg = []
        
        for t in self.table:
            msg.append({"network":t.ntwork, "netmask": t.ntmask, "peer": t.peer})
            print("below appending")
                           
        #print("message sending: " + json.dumps(msg))
        
        m[MESG] = msg
        oldsrc = m[SRCE]
        olddes = m[DEST]
        m[DEST] = oldsrc
        m[SRCE] = olddes 
        m[TYPE] = TABL
        print("got here")
        socks = self.socketsReal 
        for s in socks:
            
            for sock in self.sockets:
                        
                        if self.sockets[sock] == s:
                            print("got here2")
                            if sock == srcif:
                                print("should get here once")
                                mes = json.dumps(m)
                                print("full dump message: " + mes)
                                s.sendall(bytes(mes, 'utf-8'))
                                print("after sent dump")
        return True

    def handle_packet(self, srcif, packet):
        """	dispatches a packet """
        # TODO
        m1 = json.dumps(packet)
        m = json.loads(m1)
        
        t = m["type"]
        if t == DATA:
            return self.forward(srcif, packet)
        elif t == DUMP:
            return self.dump(srcif, packet)
        elif t == UPDT:
            return self.update(srcif, packet)
        elif t == RVKE:
            return self.revoke(packet)
        else:
            return False

    def send_error(self, conn, msg):
        """ Send a no_route error message """
        # TODO
        return

    def run(self):
        lastUpdate = True
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            
            for conn in socks:
                try:
                    k = conn.recv(65535)
                except:
                    # either died on a connection reset, or was SIGTERM's by parent
                    return
                if k:
                    for sock in self.sockets:
                        if self.sockets[sock] == conn:
                            srcif = sock
                    msg = json.loads(k)
                    print(msg)
                    m1 = json.dumps(msg)
                    m = json.loads(m1)
                    t = m["type"]
                    if lastUpdate and t != UPDT:
                        #lsat one was update and now its not
                        #so can send all of the update messages now
                        lastUpdate = False
                        print("can send update messages now")
                        for x in self.updates:
                            #what is the srcif I'm sending?
                            self.sendUpdates(x)
                    if not self.handle_packet(srcif, msg):
                        self.send_error(conn, msg)
                else:
                    return
        #now start sending everything
        return



if __name__ == "__main__":
    router = Router(args.networks, args.asn)
    router.run()
